import { DepsManager } from '@eco-pages/core';
import { DocsLayout } from '@/layouts/docs-layout';
import { CodeBlock } from '@/components/code-block/code-block.kita';
import { LiteTodoApp } from '@/components/lite-todo-app'

export const layout = DocsLayout;

export const dependencies = DepsManager.collect({
  importMeta: import.meta,
  components: [LiteTodoApp]
})

export const getMetadata = () => ({
  title: 'Docs | Lite Todo App',
  description: 'The place to learn about Eco Pages',
})

# Lite Todo App
---

The `LiteTodoApp` component is a simple todo app that uses the `LiteContext` to share the todo list between components.

In this example we are using `WithKita` mixin to use JSX in our components.

Due the usage of JSX we need to pass the initialdata as a stringified attribute. The little helper `stringifiedAttribute` is used to convert the data to a string but keeping the types.

This permits to use the data as a string in the html markup and then parse it back to an object in the component respecting the JSX definition.

<LiteTodoApp count={5} />

### Html Markup

<CodeBlock lang="html">{` <>
  <h3 safe>{data.title}</h3>
  <p safe>{data.description}</p>
  <lite-todo-app class="todo" initialdata={stringifiedAttribute(data.todos)}>
    <div class="todo__board">
      <div class="todo__panel">
        <h4>Todo List</h4>
        <div class="todo__list todo__list--incomplete" data-todo-list>
          {completedTodos.length > 0 ? <TodoList todos={incompleteTodos} /> : <NoTodosMessage />}
        </div>
      </div>
      <div class="todo__panel">
        <h4>Completed Todos</h4>
        <div class="todo__list todo__list--complete" data-todo-list-complete>
          {incompleteTodos.length > 0 ? <TodoList todos={completedTodos} /> : <NoCompletedTodosMessage />}
        </div>
      </div>
    </div>
    <form id="todo-form" data-todo-form>
      <div class="todo__todo-form-group">
        <label for="new-todo">Add Todo</label>
        <textarea form="todo-form" id="new-todo" rows="6" name="todo" />
        <button type="submit">Add</button>
      </div>
    </form>
    <div class="todo__count">
      <p>
        Still to do: <span data-count>{incompleteTodos.length}</span>
      </p>
      <p>
        Completed: <span data-count-complete>{completedTodos.length}</span>
      </p>
    </div>
  </lite-todo-app>
</>
`}</CodeBlock>

### Typescript

<CodeBlock lang='typescript'>{`import {
  LiteElement,
  WithKita,
  customElement,
  onEvent,
  querySelector,
  reactiveAttribute,
  createContext,
  consumeContext,
  contextSelector,
  provideContext,
  type UnknownContext,
  type LiteContext,
} from '@eco-pages/lite-elements';
import { NoCompletedTodosMessage, NoTodosMessage, TodoItem } from './lite-todo.templates';

export type LiteTodoAppProps = {
  initialdata?: TodoContext['todos'];
};

export type LiteTodoProps = {
  complete?: boolean;
};

export type Todo = {
  id: string;
  text: string;
  complete: boolean;
};

export type TodoContext = {
  todos: Todo[];
};

export const todoContext = createContext<TodoContext>(Symbol('todo-context'));

@customElement('lite-todo-item')
export class LiteTodo extends WithKita(LiteElement) {
  @querySelector('input[type="checkbox"]') checkbox!: HTMLInputElement;
  @reactiveAttribute({ type: Boolean, reflect: true }) complete = false;
  @consumeContext(todoContext) context!: LiteContext<typeof todoContext>;

  override connectedCallback(): void {
    super.connectedCallback();
    this.complete = this.checkbox.checked;
  }

  @onEvent({ target: 'input[type="checkbox"]', type: 'change' })
  toggleComplete(event: Event) {
    const checkbox = event.target as HTMLInputElement;
    const todo = this.context.getContext().todos.find((t) => t.id === this.id);
    if (!todo) return;
    this.complete = checkbox.checked;
    this.context.setContext({
      todos: this.context.getContext().todos.map((t) => (t.id === this.id ? { ...t, complete: checkbox.checked } : t)),
    });
    this.remove();
  }

  override disconnectedCallback(): void {
    super.disconnectedCallback();
  }
}

@customElement('lite-todo-app')
export class LiteTodos extends WithKita(LiteElement) {
  @querySelector('[data-count]') countText!: HTMLElement;
  @querySelector('[data-count-complete]') countTextComplete!: HTMLElement;
  @querySelector('[data-todo-list]') todoList!: HTMLElement;
  @querySelector('[data-todo-list-complete]') todoListComplete!: HTMLElement;
  @reactiveAttribute({ type: Array, reflect: false }) initialdata: TodoContext['todos'] = [];

  @provideContext<typeof todoContext>({ context: todoContext, initialValue: { todos: [] } })
  provider!: LiteContext<typeof todoContext>;

  override connectedCallback(): void {
    super.connectedCallback();
    this.onTodosUpdated = this.onTodosUpdated.bind(this);
  }

  override connectedContextCallback(_contextName: UnknownContext): void {
    this.provider.setContext({ todos: this.initialdata });
  }

  @onEvent({ target: '[data-todo-form]', type: 'submit' })
  submitTodo(event: FormDataEvent) {
    event.preventDefault();
    const form = event.target as HTMLFormElement;
    const formData = new FormData(form);
    const todo = formData.get('todo');

    if (todo) {
      const prevTodos = this.provider.getContext().todos;
      const todos = [...prevTodos, { id: Date.now().toString(), text: todo.toString(), complete: false }];
      this.provider.setContext({ todos });
      form.reset();
    }
  }

  renderTodos(todos: TodoContext['todos'], node: HTMLElement) {
    node.innerHTML = '';
    let index = 0;
    for (const todo of todos) {
      this.renderTemplate({
        target: node,
        template: <TodoItem {...todo} />,
        insert: index === 0 ? 'replace' : 'beforeend',
      });
      index++;
    }
  }

  renderMessage(message: JSX.Element, node: HTMLElement) {
    this.renderTemplate({
      target: node,
      template: message,
      insert: 'replace',
    });
  }

  @contextSelector({
    context: todoContext,
    select: ({ todos }) => ({
      todosCompleted: todos.filter((todo) => todo.complete),
      todosIncomplete: todos.filter((todo) => !todo.complete),
    }),
  })
  onTodosUpdated({
    todosCompleted,
    todosIncomplete,
  }: {
    todosCompleted: TodoContext['todos'];
    todosIncomplete: TodoContext['todos'];
  }) {
    if (todosCompleted.length === 0) {
      this.renderMessage(<NoTodosMessage />, this.todoListComplete);
    } else {
      this.renderTodos(todosCompleted, this.todoListComplete);
    }

    if (todosIncomplete.length === 0) {
      this.renderMessage(<NoCompletedTodosMessage />, this.todoList);
    } else {
      this.renderTodos(todosIncomplete, this.todoList);
    }

    this.countTextComplete.textContent = todosCompleted.length.toString();
    this.countText.textContent = todosIncomplete.length.toString();
  }
}

declare global {
  namespace JSX {
    interface IntrinsicElements {
      'lite-todo-app': HtmlTag & LiteTodoAppProps;
      'lite-todo-item': HtmlTag & LiteTodoProps;
    }
  }
}`}</CodeBlock>

### Templates

<CodeBlock lang='typescript'>{`import type { Todo } from './lite-todo-app.script';

export const NoTodosMessage = () => {
  return <div>No todos to show</div>;
};

export const NoCompletedTodosMessage = () => {
  return <div>No completed todos to show</div>;
};

export const TodoItem = ({ id, complete, text }: Todo) => {
  return (
    <lite-todo-item complete={complete} class="todo__item" id={id}>
      {text as 'safe'}
      <span>
        <input type="checkbox" checked={complete} />
      </span>
    </lite-todo-item>
  );
};

export const TodoList = ({ todos }: { todos: Todo[] }) => {
  return (
    <>
      {todos.map((todo) => (
        <TodoItem {...todo} />
      ))}
    </>
  );
};`}</CodeBlock>